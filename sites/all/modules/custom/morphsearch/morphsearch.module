<?php
/**
 * Implements hook_block_info(). Declares that the 'morphsearch-block' is provided by this module.
 *
 * @return array Each component of the which is an array of block information.
 *               The array keys are the 'delta' values used in other block hooks.
 */
function morphsearch_block_info() {
  $blocks['morphsearch-block'] = array(
    'info' => t('Morphsearch Block'),
    'cache' => DRUPAL_CACHE_GLOBAL, // The block is the same for every user on every page where it is visible.
    //'cache' => DRUPAL_NO_CACHE,
    'status' => TRUE,
    'region' => 'sidebar_second',
  );

  return $blocks;
}


/**
 * Implements hook_block_view(). Generates the content of the 'morphsearch-block' block.
 *
 * @param string $delta : Which block to render. This is a unique identifier for the block within the module,
 *                        defined in hook_block_info().
 * @return array  Either an empty array so the block will not be shown or an array containing the following elements:
 *              subject: The default localized title of the block. If the block does not have a default title,
 *                       this should be set to NULL.
 *              content: The content of the block's body. This may be a renderable array (preferable) or a string
 *                       containing rendered HTML content. If the content is empty the block will not be shown.
 */
function morphsearch_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'morphsearch-block':
      //drupal_add_js(drupal_get_path('module', 'morphsearch') . "/js/morphsearch.js", array('scope' => 'footer'));

      //$block['subject'] = t('Morphsearch Block');
      $block['content'] = createMorphsearchContent();

      // Attach morphsearch CSS to block.
      $block['content']['#attached']['css'] = array(drupal_get_path('module', 'morphsearch') . "/css/morphsearch.css");
      $block['content']['#attached']['js'][] = array(
        'data' => drupal_get_path('module', 'morphsearch') . "/js/morphsearch.js",
        'scope' => 'footer',
      );
      break;
  }
  // add qtip2 library to display search syntax as a tooltip
  libraries_load('qtip');

  return $block;
}


/**
 * Generate block content (fulltext search, morphological search, typographic search, submit, ...).
 *
 * @return array Renderable array containing the block's body.
 */
function createMorphsearchContent() {
  // taxonomy SQL table/field info https://atlas-indeko.slack.com/archives/development/p1474617733000003
  // DB queries als Referenz/Vergleich z.B. auch in den anderen custom Modulen von Julien (interestedGroups.module, ...)

  $content = array();

  $content = array(
    // fulltext search element
    'fulltextsearch' => array(
      '#type' => 'textfield',
      '#title' => t('Portalsuche'),
      '#attributes' => array(
        'class' => array('morphsearch-fulltext'),
        'id' => 'fulltextsearch',
      ),
      '#prefix' => '<div id="fulltextsearchrow">'
    ),

    // search info icon
    'fulltextsearchimage' => array(
      '#markup' => '<span title="Use tooltip to display search syntax? See qtip^2 plugin already used by morphmapping module." ' .
        'id="fulltextsearchinfo"></span>',
      '#suffix' => '</div>',
    ),

    // HTML help about the available search syntax
    'searchSyntax' => array(
      '#markup' => buildSearchSyntax(),
    ),

    // all type search elements
    'typesearch' => array('#type' => 'select',
      '#title' => t('Inhaltstypensuche (POC, no functionality):'),
      '#options' => node_type_get_names(), // drupal function, returns all content type names
      '#attributes' => array(
        'class' => array('morphsearch-type'),
        'id' => 'typesearch',
        'style' => 'width: 100%;',
      )
    ),

    // all morphological search elements
    'morphsearch' => array(
      '#markup' => buildSearchHtml(),
      '#prefix' => '<a href="javascript:void(0)" id="morphsearch-select-block-toggle">'.t('Morphologische Suche').'</a>' .
        '<div id="morphsearch-select-block">',
      '#suffix' => '</div>',
    ),

    // reset search block link
    'reset' => array(
      '#markup' => '<a href="javascript:void(0)" id="morphsearch-reset">'.t('Suche zurücksetzen').'</a>',
      '#prefix' => '<div class="morphblocktable"><div class="morphblockcell">'
    ),

    // save selected search block elements link
    'savesearch' => array(
      '#markup' => '<a href="javascript:void(0)" id="morphsearch-save">'.t('Suche speichern').'</a>',
      '#suffix' => '</div>'

    ),

    // execute search button
    'submit' => array(
      '#type' => 'submit',
      '#value' => t('Suche'),
      '#id' => 'searchbutton',
      '#suffix' => '</div>',

    ),
  );

  return $content;
}

/**
 * Creates the HTML for the dynamic search block.
 *
 * @return string Contains the HTML code for the dynamic morphological search block.
 */
function buildSearchHtml() {

  $query = "SELECT taxonomy_vocabulary.name AS vocabulary_name, taxonomy_vocabulary.machine_name AS vocabulary_machinename,
              taxonomy_vocabulary.vid AS vocabulary_vid, taxonomy_term_data.name AS term_name, taxonomy_term_data.vid AS term_vid,
              taxonomy_term_data.tid AS tid, taxonomy_vocabulary.weight AS vocabulary_weight, taxonomy_term_data.weight AS term_weight 
            FROM {taxonomy_term_data} taxonomy_term_data
            LEFT JOIN {taxonomy_vocabulary} taxonomy_vocabulary ON taxonomy_term_data.vid = taxonomy_vocabulary.vid
            WHERE taxonomy_vocabulary.machine_name LIKE 'tax_morph_%'
            ORDER BY vocabulary_name ASC, term_weight ASC;";
  $result = db_query($query);

  $html = '';

  // Drupal translatable placeholder text if no element is selected
  $placeholderSingle = t("Choose an option");
  $placeholderMulti = t("Choose some options");

  $currentLabel = '';
  foreach ($result as $row) {

    // new morphological item, add new label and select
    if ($currentLabel !== $row->vocabulary_name) {
      if ($currentLabel !== '') {
        $html .= "</select>";
        $html .= "</label>";
      }

      // create label for new select box
      $html .= "<label>$row->vocabulary_name";

      // Check for multivalued morphological item
      if (strpos($row->vocabulary_machinename, 'tax_morph_m_') === false) { // singleselect
        $html .= "<select class='morphsearch-select' data-placeholder='$placeholderSingle'>";
      } else { // multiselect
        $html .= "<select multiple='multiple' class='morphsearch-select' size='1' data-placeholder='$placeholderMulti'>";
      }

      // add an empty select option for every select box
      $html .= "<option value=''></option>";

      $currentLabel = $row->vocabulary_name;
    }

    // add all options to the current select box
    $html .= "<option value='$row->tid'>$row->term_name</option>";
  }

  // close tags after last element
  $html .= "</select>";
  $html .= "</label>";
  return $html;
}

/**
 * Creates the HTML for the search syntax tooltip.
 *
 * @return string Contains the HTML code for the search syntax tooltip.
 */
function buildSearchSyntax() {
  $html = '';
  $html .= '<div id="searchSyntax" class="element-hidden">
              <table id="searchSyntaxTable">
                <tr>
                  <td>+</td>
                  <td>Wortkombination (kann weggelassen werden)</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>Schließt Ergebnisse aus, die den Begriff enthalten</td>
                </tr>
                <tr>
                  <td>"xxx"</td>
                  <td>Ergebnisse mit exakter Übereinstimmung</td>
                </tr>
                <tr>
                  <td>|</td>
                  <td>Entweder-Oder-Suche</td>
                </tr>
                <tr>
                  <td>*</td>
                  <td>Wildcard-Suche, wenn Teile des Strings unbekannt sind</td>
                </tr>
                <tr>
                  <td>Filetype:</td>
                  <td>Suche nach bestimmten Dateitypen</td>
                </tr>
                <tr>
                  <td>Autor: / Author:</td>
                  <td>Suche nach bestimmten Autoren</td>
                </tr>
                <tr>
                  <td>URL:</td>
                  <td>Suche nach verlinkten Adressen</td>
                </tr>
                <tr>
                  <td>ISBN: / DOI:</td>
                  <td>Suche nach referenzierten ISBN/DOI-Nummern</td>
                </tr>
              </table>
            </div>';
  return $html;
}


/**
 * Implements hook_libraries_info().
 * Register qtip2 library to conviniently load it with libraries_load('qtip'); in any module.
 */
function morphsearch_libraries_info() {
  $libraries['qtip'] = array(
    'name'              => 'qTip2',
    'vendor url'        => 'http://qtip2.com',
    'download url'      => 'http://qtip2.com/download',
    'version arguments' => array(
      'file'    => 'jquery.qtip.min.js',
      'pattern' => '/\/\* qtip2 v([0-9\.]{5})/',
      'lines'   => 1,
    ),
    'files' => array(
      'js' => array(
        'jquery.qtip.min.js',
      ),
      'css' => array(
        'jquery.qtip.min.css',
      ),
    ),
  );

  return $libraries;
}

/**
 * For some reason CURRENT_TIMESTAMP is not accepted as default value during schema definition,
 * so change it on enabling the module.
 */
function morphsearch_enable() {
  db_query('
      ALTER TABLE {morphsearch_saved_input}
      MODIFY timestamp TIMESTAMP NOT NULL
      DEFAULT CURRENT_TIMESTAMP
      ON UPDATE CURRENT_TIMESTAMP'
  );
}

/**
 * Implementation of hook_menu.
 * Used to receive data from AJAX equest.
 */
function morphsearch_menu() {
  $items['usersavesearch'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'save_search',
    'access arguments' => array('access content'),
  );

  return $items;
}

/**
 * Saved search data from JS AJAX request to database.
 *
 * @return DatabaseStatementInterface|int Unique ID of the inserted row.
 */
function save_search() {
  $data = $_POST['saveData'];
  $url = $_POST['saveUrl'];

  global $user;

  $id = db_insert('morphsearch_saved_input')
    ->fields(array(
      'user_id' => $user->uid,
      'input' => $data,
      'url' => $url,
    ))
    ->execute();

  return $id;
}