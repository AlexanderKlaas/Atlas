<?php
/**
 * Implements hook_block_info(). Declares that the 'morphsearch-block' is provided by this module.
 *
 * @return array Each component of the which is an array of block information.
 *               The array keys are the 'delta' values used in other block hooks.
 */
function morphsearch_block_info() {
  $blocks['morphsearch-block'] = array(
    'info' => t('Morphsearch Block'),
    'cache' => DRUPAL_CACHE_GLOBAL, // The block is the same for every user on every page where it is visible.
    //'cache' => DRUPAL_NO_CACHE,
    'status' => TRUE,
    'region' => 'sidebar_second',
  );

  return $blocks;
}


/**
 * Implements hook_block_view(). Generates the content of the 'morphsearch-block' block.
 *
 * @param string $delta : Which block to render. This is a unique identifier for the block within the module,
 *                        defined in hook_block_info().
 * @return array  Either an empty array so the block will not be shown or an array containing the following elements:
 *              subject: The default localized title of the block. If the block does not have a default title,
 *                       this should be set to NULL.
 *              content: The content of the block's body. This may be a renderable array (preferable) or a string
 *                       containing rendered HTML content. If the content is empty the block will not be shown.
 */
function morphsearch_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'morphsearch-block':
      //drupal_add_js(drupal_get_path('module', 'morphsearch') . "/js/morphsearch.js", array('scope' => 'footer'));

      //$block['subject'] = t('Morphsearch Block');
      $block['content'] = createMorphsearchContent();

      // Attach morphsearch CSS to block.
      $block['content']['#attached']['css'] = array(drupal_get_path('module', 'morphsearch') . "/css/morphsearch.css");
      $block['content']['#attached']['js'][] = array(
        'data' => drupal_get_path('module', 'morphsearch') . "/js/morphsearch.js",
        'scope' => 'footer',
      );
      break;
  }
  // add qtip2 library to display search syntax as a tooltip
  libraries_load('qtip');

  return $block;
}


/**
 * Generate block content (fulltext search, morphological search, typographic search, submit, ...).
 *
 * @return array Renderable array containing the block's body.
 */
function createMorphsearchContent() {
  // taxonomy SQL table/field info https://atlas-indeko.slack.com/archives/development/p1474617733000003
  // DB queries als Referenz/Vergleich z.B. auch in den anderen custom Modulen von Julien (interestedGroups.module, ...)

  $content = array();

  // fulltext search element
  $content['fulltextsearch'] = array(
    '#type' => 'textfield',
    '#title' => t('Portalsuche'),
    '#attributes' => array(
      'class' => array('morphsearch-fulltext'),
      'id' => 'fulltextsearch',
    ),
    '#prefix' => '<div id="fulltextsearchrow">'
  );

  // search info icon
  $content['fulltextsearchimage'] = array(
    '#markup' => '<span title="Use tooltip to display search syntax? See qtip^2 plugin already used by morphmapping module." ' .
      'id="fulltextsearchinfo"></span>',
    '#suffix' => '</div>',
  );

  // HTML help about the available search syntax
  $content['searchSyntax'] = array(
    '#markup' => buildSearchSyntax(),
  );

  // all type search elements
  $content['typesearch'] = array(
    '#type' => 'select',
    '#title' => t('Inhaltstypensuche (POC, no functionality):'),
    '#options' => node_type_get_names(), // drupal function, returns all content type names
    '#attributes' => array(
      'class' => array('morphsearch-type'),
      'id' => 'typesearch',
      'style' => 'width: 100%;',
    )
  );

  // all morphological search elements
  $content['morphsearch'] = array(
    '#markup' => buildSearchHtml(),
    '#prefix' => '<a href="javascript:void(0)" id="morphsearch-select-block-toggle">' . t('Morphologische Suche') . '</a>' .
      '<div id="morphsearch-select-block">',
    '#suffix' => '</div>',
  );

  // reset search filter link
  $content['reset'] = array(
    '#markup' => '<a href="javascript:void(0)" id="morphsearch-reset">' . t('Filter zurücksetzen') . '</a>',
    '#prefix' => '<div class="morphblocktable"><div class="morphblockcell">'
  );

  // save selected search block elements link (only for logged in users)
  if (user_is_logged_in()) {
    $content['savesearch'] = array(
      '#markup' => '<a href="javascript:void(0)" id="morphsearch-save">' . t('Suche speichern') . '</a>',
      '#suffix' => '</div>'
    );
  } else {
    $content['closediv'] = array(
      '#suffix' => '</div>'
    );
  }

  // execute search button
  $content['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Suche'),
    '#id' => 'searchbutton',
    '#suffix' => '</div>',
  );

  return $content;
}

/**
 * Creates the HTML for the dynamic search block.
 *
 * @return string Contains the HTML code for the dynamic morphological search block.
 */
function buildSearchHtml() {

  $query = "SELECT taxonomy_vocabulary.name AS vocabulary_name, taxonomy_vocabulary.machine_name AS vocabulary_machinename,
              taxonomy_vocabulary.vid AS vocabulary_vid, taxonomy_term_data.name AS term_name, taxonomy_term_data.vid AS term_vid,
              taxonomy_term_data.tid AS tid, taxonomy_vocabulary.weight AS vocabulary_weight, taxonomy_term_data.weight AS term_weight 
            FROM {taxonomy_term_data} taxonomy_term_data
            LEFT JOIN {taxonomy_vocabulary} taxonomy_vocabulary ON taxonomy_term_data.vid = taxonomy_vocabulary.vid
            WHERE taxonomy_vocabulary.machine_name LIKE 'tax_morph_%'
            ORDER BY vocabulary_name ASC, term_weight ASC;";
  $result = db_query($query);

  $html = '';

  // Drupal translatable placeholder text if no element is selected
  $placeholderSingle = t("Choose an option");
  $placeholderMulti = t("Choose some options");

  $currentLabel = '';
  foreach ($result as $row) {

    // new morphological item, add new label and select
    if ($currentLabel !== $row->vocabulary_name) {
      if ($currentLabel !== '') {
        $html .= "</select>";
        $html .= "</label>";
      }

      // create label for new select box
      $html .= "<label>$row->vocabulary_name";

      // Check for multivalued morphological item
      if (strpos($row->vocabulary_machinename, 'tax_morph_m_') === false) { // singleselect
        $html .= "<select class='morphsearch-select' data-placeholder='$placeholderSingle'>";
      } else { // multiselect
        $html .= "<select multiple='multiple' class='morphsearch-select' size='1' data-placeholder='$placeholderMulti'>";
      }

      // add an empty select option for every select box
      $html .= "<option value=''></option>";

      $currentLabel = $row->vocabulary_name;
    }

    // add all options to the current select box
    $html .= "<option value='$row->tid'>$row->term_name</option>";
  }

  // close tags after last element
  $html .= "</select>";
  $html .= "</label>";
  return $html;
}

/**
 * Creates the HTML for the search syntax tooltip.
 *
 * @return string Contains the HTML code for the search syntax tooltip.
 */
function buildSearchSyntax() {
  $html = '';
  $html .= '<div id="searchSyntax" class="element-hidden">
              <table id="searchSyntaxTable">
                <tr>
                  <td>+</td>
                  <td>Wortkombination (kann weggelassen werden)</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>Schließt Ergebnisse aus, die den Begriff enthalten</td>
                </tr>
                <tr>
                  <td>"xxx"</td>
                  <td>Ergebnisse mit exakter Übereinstimmung</td>
                </tr>
                <tr>
                  <td>|</td>
                  <td>Entweder-Oder-Suche</td>
                </tr>
                <tr>
                  <td>*</td>
                  <td>Wildcard-Suche, wenn Teile des Strings unbekannt sind</td>
                </tr>
                <tr>
                  <td>Filetype:</td>
                  <td>Suche nach bestimmten Dateitypen</td>
                </tr>
                <tr>
                  <td>Autor: / Author:</td>
                  <td>Suche nach bestimmten Autoren</td>
                </tr>
                <tr>
                  <td>URL:</td>
                  <td>Suche nach verlinkten Adressen</td>
                </tr>
                <tr>
                  <td>ISBN: / DOI:</td>
                  <td>Suche nach referenzierten ISBN/DOI-Nummern</td>
                </tr>
              </table>
            </div>';
  return $html;
}


/**
 * Implements hook_libraries_info().
 * Register qtip2 library to conviniently load it with libraries_load('qtip'); in any module.
 */
function morphsearch_libraries_info() {
  $libraries['qtip'] = array(
    'name'              => 'qTip2',
    'vendor url'        => 'http://qtip2.com',
    'download url'      => 'http://qtip2.com/download',
    'version arguments' => array(
      'file'    => 'jquery.qtip.min.js',
      'pattern' => '/\/\* qtip2 v([0-9\.]{5})/',
      'lines'   => 1,
    ),
    'files' => array(
      'js' => array(
        'jquery.qtip.min.js',
      ),
      'css' => array(
        'jquery.qtip.min.css',
      ),
    ),
  );

  return $libraries;
}

/**
 * For some reason CURRENT_TIMESTAMP is not accepted as default value during schema definition,
 * so change it on enabling the module.
 */
function morphsearch_enable() {
  db_query('
      ALTER TABLE {morphsearch_saved_input}
      MODIFY timestamp TIMESTAMP NOT NULL
      DEFAULT CURRENT_TIMESTAMP
      ON UPDATE CURRENT_TIMESTAMP'
  );
}

/**
 * Implementation of hook_menu.
 * Used to receive data from AJAX equest.
 */
function morphsearch_menu() {
  $items['user/savesearch/ajax'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'save_search',
    'access callback' => 'user_is_logged_in',
  );

  $items['user/deletesearch/ajax'] = array(
      'type' => MENU_CALLBACK,
      'page callback' => 'delete_search',
      'access callback' => 'user_is_logged_in',
  );

  return $items;
}

/**
 * Function to delete the saved search data from the database.
 *
 * @return JSON object containing the deleted search of the user.
 */
function delete_search() {
  global $user;
  $id = $_POST['savedSearchId'];

  $id_deleted = db_delete('morphsearch_saved_input')
      -> condition('id', $id)
      -> execute();

  return drupal_json_output($id);
}


/**
 * Save search data from JS AJAX request to database.
 *
 * @return JSON object containing the save result and result message for the user.
 */

function save_search() {
  global $user;
  $data = $_POST['saveData'];
  $url = $_POST['saveUrl'];
  $uid = $user->uid;

  // don't save duplicate search
  if (is_duplicate_search($uid, $data)) {
    $output = array('success' => 'false', 'message' => t('Die Suche wurde bereits gespeichert.'));
    return drupal_json_output($output);

  } else {
    try {
      $id = db_insert('morphsearch_saved_input')
        ->fields(array(
          'user_id' => $uid,
          'input' => $data,
          'url' => $url,
        ))
        ->execute();

      $output = array('success' => 'true', 'message' => t('Die Suche wurde erfolgreich unter Mein Konto gespeichert.'));
      return drupal_json_output($output);

    } catch (Exception $e) {
      $output = array('success' => 'false', 'message' => t('Die Suche wurde nicht gespeichert.'));
      return drupal_json_output($output);
    }
  }
}

/**
 * Checks if the same search is already in the database.
 *
 * @param $uid ID of the user
 * @param $data search parameter array to be saved
 * @return bool TRUE if user already saved the an identical search, FALSE otherwise
 */
function is_duplicate_search($uid, $data) {
  $isDuplicate = false;

  $query = "SELECT id FROM {morphsearch_saved_input}
            WHERE user_id = :uid AND input = :input;";
  $result = db_query($query, array(":uid" => $uid, ":input" => $data));

  // the entry is a duplicate if there are results
  if ($result->rowCount() > 0) {
    $isDuplicate = true;
  }

  return $isDuplicate;
}

/**
 * Implements Hook_user_view_alter.
 *
 * @param $build
 */
function morphsearch_user_view_alter(&$build) {
  // Add a #post_render callback to act on the rendered HTML of the user.
  $build['#post_render'][] = 'morphsearch_user_post_render';
}

/**
 * Implements Hook_views_post_render.
 *
 * @param $element
 * @param $form_state
 * @return string
 */
function morphsearch_user_post_render($element, $form_state) {
  global $user;
  $uid = $user->uid;

  $query = "SELECT id, timestamp FROM {morphsearch_saved_input}
            WHERE user_id = :uid;";
  $result = db_query($query, array(":uid" => $uid));
  $result = $result->fetchAll();

  /* Dummy for saved Search. */
  $html = "<h3>Gespeicherte Suchen</h3>";
  foreach($result as $currentresult) {

    $html .= "<fieldset id='" . $currentresult->id . "'>";
    /* Format date to fit the mockup. */
    $html .= "<legend>" . "Suche vom " . $new_date = date('d.m.Y', strtotime($currentresult->timestamp)) . "</legend>";
    $html .= "<table>";
    $html .= "<tr>";
    $html .= "<td>" . "Kompetenzentwicklung:" . "</td>";
    $html .= "<td>" . "Individuell, Führungskräfte" . "</td>";
    $html .= "<td>" . "<div class='actions' id='". $currentresult->id . "'><a class='delete'>Löschen</a><div class='confirmation' 
                      style='display:none;'><h4>Diese Suche wirklich löschen?</h4><button class='no'>Nein</button><button 
                      class='yes' onclick='javascript:Indeko.Morphsearch.deleteSavedSearch(" . $currentresult->id . ");'>Ja</button></div></div>" . "</td>";
    $html .= "</tr>";
    $html .= "<tr>";
    $html .= "<td>" . "Unternehmensgröße:" . "</td>";
    $html .= "<td>" . "Kleinunternehmen" . "</td>";
    $html .= "<td>" . "<a href='url'>>> Zu den Ergebnissen</a>" . "</td>";
    $html .= "</tr>";
    $html .= "</tr>";
    $html .= "<tr>";
    $html .= "<td>" . "Forschungsergebnistyp:" . "</td>";
    $html .= "<td>" . "Theorie" . "</td>";
    $html .= "</tr>";
    $html .= "<tr>";
    $html .= "<td>" . "Projektstart:" . "</td>";
    $html .= "<td>" . "März 2015" . "</td>";
    $html .= "</tr>";
    $html .= "</table>";
    $html .= "</fieldset>";
  }

  return $element . $html;
}
