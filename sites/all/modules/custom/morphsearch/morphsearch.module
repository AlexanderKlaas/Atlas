<?php
/**
 * Implement hook_schema()
 */
function morphsearch_verteiler_schema() {
  $schema = array();

  $schema['morphsearch_saved_input'] = array(
    'description' => 'The table for the saved users searches',
    'fields' => array(
      'id' => array(
        'description' => 'The primary identifier for saved user searches.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'user_id' => array(
        'description' => 'The user identifier for the user saved input.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'input' => array(
        'description' => 'The saved search input.',
        'type' => 'varchar',
        'length' => 10000,
        'not null' => TRUE,
        'default' => '',
      ),
      'timestamp' => array(
        'description' => 'The timestamp.',
        'type' => 'datetime',
        'mysql_type' => 'DATETIME',     // The equivalent MySQL data type
        'pgsql_type' => 'timestamp',    // The equivalent PostgreSQL data type
        'not null' => TRUE,
      ),
    ),

    'primary key' => array('id'),
  );


  return $schema;
}

/**
 * Implements hook_update_N()
 */
function morphsearch_verteiler_update_7000() {
  drupal_install_schema('morphsearch_saved_input');
}

/**
 * Implements hook_block_info(). Declares that the 'morphsearch-block' is provided by this module.
 *
 * @return array Each component of the which is an array of block information.
 *               The array keys are the 'delta' values used in other block hooks.
 */
function morphsearch_block_info() {
  $blocks['morphsearch-block'] = array(
    'info' => t('Morphsearch Block'),
    'cache' => DRUPAL_CACHE_GLOBAL, // The block is the same for every user on every page where it is visible.
    //'cache' => DRUPAL_NO_CACHE,
    'status' => TRUE,
    'region' => 'sidebar_second',
  );

  return $blocks;
}


/**
 * Implements hook_block_view(). Generates the content of the 'morphsearch-block' block.
 *
 * @param string $delta : Which block to render. This is a unique identifier for the block within the module,
 *                        defined in hook_block_info().
 * @return array  Either an empty array so the block will not be shown or an array containing the following elements:
 *              subject: The default localized title of the block. If the block does not have a default title,
 *                       this should be set to NULL.
 *              content: The content of the block's body. This may be a renderable array (preferable) or a string
 *                       containing rendered HTML content. If the content is empty the block will not be shown.
 */
function morphsearch_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'morphsearch-block':
      //drupal_add_js(drupal_get_path('module', 'morphsearch') . "/js/morphsearch.js", array('scope' => 'footer'));

      //$block['subject'] = t('Morphsearch Block');
      $block['content'] = createMorphsearchContent();

      // Attach morphsearch CSS to block.
      $block['content']['#attached']['css'] = array(drupal_get_path('module', 'morphsearch') . "/css/morphsearch.css");
      $block['content']['#attached']['js'][] = array(
        'data' => drupal_get_path('module', 'morphsearch') . "/js/morphsearch.js",
        'scope' => 'footer',
      );
      break;
  }
  // add qtip2 library to display search syntax as a tooltip
  libraries_load('qtip');

  return $block;
}


/**
 * Generate block content (fulltext search, morphological search, typographic search, submit, ...).
 *
 * @return array Renderable array containing the block's body.
 */
function createMorphsearchContent() {
  // taxonomy SQL table/field info https://atlas-indeko.slack.com/archives/development/p1474617733000003
  // DB queries als Referenz/Vergleich z.B. auch in den anderen custom Modulen von Julien (interestedGroups.module, ...)

  $content = array();

  $content = array(
    // create elements using form API
    'fulltextsearch' => array(
      '#type' => 'textfield',
      '#title' => t('Portalsuche'),
      '#attributes' => array(
        'class' => array('morphsearch-fulltext'),
        'id' => 'fulltextsearch',
        ),
      '#prefix' => '<div id="fulltextsearchrow">'
    ),

    'fulltextsearchimage' => array(
      '#markup' => '<span title="Use tooltip to display search syntax? See qtip^2 plugin already used by morphmapping module." ' .
                    'id="fulltextsearchinfo"></span>',
      '#suffix' => '</div>',
    ),

    'searchSyntax' => array(
      '#markup' => buildSearchSyntax(),
    ),

    'typesearch' => array('#type' => 'select',
      '#title' => t('Inhaltstypensuche (POC, no functionality):'),
      '#options' => node_type_get_names(), // drupal function, returns all content type names
      '#attributes' => array(
        'class' => array('morphsearch-type'),
        'id' => 'typesearch',
        'style' => 'width: 100%;',
      )
    ),

    // and pure html output
    'morphsearch' => array(
      '#markup' => buildSearchHtml(),
      '#prefix' => '<a href="#blank" id="morphsearch-select-block-toggle">Morphologische Suche</a>' .
                   '<div id="morphsearch-select-block">',
      '#suffix' => '</div>',
    ),

    'submit' => array(
      '#type' => 'submit',
      '#value' => t('Suche'),
      '#name' => 'searchbutton',
    ),

    'reset' => array(
      '#markup' => "<button id='morphsearch-reset'>Reset</button>",
    ),
  );

  return $content;
}

/**
 * Creates the HTML for the dynamic search block.
 *
 * @return string Contains the HTML code for the dynamic morphological search block.
 */
function buildSearchHtml() {

  $query = "SELECT taxonomy_vocabulary.name AS vocabulary_name, taxonomy_vocabulary.machine_name AS vocabulary_machinename,
              taxonomy_vocabulary.vid AS vocabulary_vid, taxonomy_term_data.name AS term_name, taxonomy_term_data.vid AS term_vid,
              taxonomy_term_data.tid AS tid, taxonomy_vocabulary.weight AS vocabulary_weight, taxonomy_term_data.weight AS term_weight 
            FROM {taxonomy_term_data} taxonomy_term_data
            LEFT JOIN {taxonomy_vocabulary} taxonomy_vocabulary ON taxonomy_term_data.vid = taxonomy_vocabulary.vid
            WHERE taxonomy_vocabulary.machine_name LIKE 'tax_morph_%'
            ORDER BY vocabulary_name ASC, term_weight ASC;";
  $result = db_query($query);

  $html = '';

  // Drupal translatable placeholder text if no element is selected
  $placeholderSingle = t("Choose an option");
  $placeholderMulti = t("Choose some options");

  $currentLabel = '';
  foreach ($result as $row) {

    // new morphological item, add new label and select
    if ($currentLabel !== $row->vocabulary_name) {
      if ($currentLabel !== '') {
        $html .= "</select>";
        $html .= "</label>";
      }

      $html .= "<label>$row->vocabulary_name";

      // Check for multivalued morphological item
      if (strpos($row->vocabulary_machinename, 'tax_morph_m_') === false) { // singleselect
        $html .= "<select class='morphsearch-select' data-placeholder='$placeholderSingle'>";
      } else { // multiselect
        $html .= "<select multiple='multiple' class='morphsearch-select' size='1' data-placeholder='$placeholderMulti'>";
      }

      $html .= "<option value=''></option>";

      $currentLabel = $row->vocabulary_name;
    }

    $html .= "<option value='$row->tid'>$row->term_name</option>";
  }

  $html .= "</select>";
  $html .= "</label>";
  return $html;
}

/**
 * Creates the HTML for the search syntax tooltip.
 *
 * @return string Contains the HTML code for the search syntax tooltip.
 */
function buildSearchSyntax() {
  $html = '';
  $html .= '<div id="searchSyntax" class="element-hidden">
              <table id="searchSyntaxTable">
                <tr>
                  <td>+</td>
                  <td>Wortkombination (kann weggelassen werden)</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>Schließt Ergebnisse aus, die den Begriff enthalten</td>
                </tr>
                <tr>
                  <td>"xxx"</td>
                  <td>Ergebnisse mit exakter Übereinstimmung</td>
                </tr>
                <tr>
                  <td>|</td>
                  <td>Entweder-Oder-Suche</td>
                </tr>
                <tr>
                  <td>*</td>
                  <td>Wildcard-Suche, wenn Teile des Strings unbekannt sind</td>
                </tr>
                <tr>
                  <td>Filetype:</td>
                  <td>Suche nach bestimmten Dateitypen</td>
                </tr>
                <tr>
                  <td>Autor: / Author:</td>
                  <td>Suche nach bestimmten Autoren</td>
                </tr>
                <tr>
                  <td>URL:</td>
                  <td>Suche nach verlinkten Adressen</td>
                </tr>
                <tr>
                  <td>ISBN: / DOI:</td>
                  <td>Suche nach referenzierten ISBN/DOI-Nummern</td>
                </tr>
              </table>
            </div>';
  return $html;
}


/**
 * Implements hook_libraries_info().
 * Register qtip2 library to conviniently load it with libraries_load('qtip'); in any module.
 */
function morphsearch_libraries_info() {
  $libraries['qtip'] = array(
    'name'              => 'qTip2',
    'vendor url'        => 'http://qtip2.com',
    'download url'      => 'http://qtip2.com/download',
    'version arguments' => array(
      'file'    => 'jquery.qtip.min.js',
      'pattern' => '/\/\* qtip2 v([0-9\.]{5})/',
      'lines'   => 1,
    ),
    'files' => array(
      'js' => array(
        'jquery.qtip.min.js',
      ),
      'css' => array(
        'jquery.qtip.min.css',
      ),
    ),
  );

  return $libraries;
}
